From 4a05f2e99cc8f38d6061c3a2642068f7b523a87d Mon Sep 17 00:00:00 2001
From: maniatro111 <florin.postolache80@gmail.com>
Date: Sat, 2 Jul 2022 21:41:37 +0300
Subject: [PATCH] Remove VDSO related defines to avoid usage

This patch removes all VDSO related defines to avoid calling the
__vdsosym function which will cause a segfault.

Signed-off-by: maniatro111 <florin.postolache80@gmail.com>
---
 arch/aarch64/syscall_arch.h |  4 --
 arch/arm/syscall_arch.h     |  4 --
 arch/i386/syscall_arch.h    |  4 --
 arch/mips/syscall_arch.h    |  4 --
 arch/mips64/syscall_arch.h  |  4 --
 arch/mipsn32/syscall_arch.h |  4 --
 arch/x86_64/syscall_arch.h  |  6 ---
 src/internal/vdso.c         | 93 -------------------------------------
 src/sched/sched_getcpu.c    | 29 ------------
 src/time/clock_gettime.c    | 34 --------------
 10 files changed, 186 deletions(-)
 delete mode 100644 src/internal/vdso.c

diff --git a/arch/aarch64/syscall_arch.h b/arch/aarch64/syscall_arch.h
index 25f5ce6..038283c 100644
--- a/arch/aarch64/syscall_arch.h
+++ b/arch/aarch64/syscall_arch.h
@@ -70,7 +70,3 @@ static inline long __syscall6(long n, long a, long b, long c, long d, long e, lo
 	register long x5 __asm__("x5") = f;
 	__asm_syscall("r"(x8), "0"(x0), "r"(x1), "r"(x2), "r"(x3), "r"(x4), "r"(x5));
 }
-
-#define VDSO_USEFUL
-#define VDSO_CGT_SYM "__kernel_clock_gettime"
-#define VDSO_CGT_VER "LINUX_2.6.39"
diff --git a/arch/arm/syscall_arch.h b/arch/arm/syscall_arch.h
index 6023303..ebb71a6 100644
--- a/arch/arm/syscall_arch.h
+++ b/arch/arm/syscall_arch.h
@@ -73,8 +73,4 @@ static inline long __syscall6(long n, long a, long b, long c, long d, long e, lo
 	__asm_syscall("r"(r7), "0"(r0), "r"(r1), "r"(r2), "r"(r3), "r"(r4), "r"(r5));
 }
 
-#define VDSO_USEFUL
-#define VDSO_CGT_SYM "__vdso_clock_gettime"
-#define VDSO_CGT_VER "LINUX_2.6"
-
 #define SYSCALL_FADVISE_6_ARG
diff --git a/arch/i386/syscall_arch.h b/arch/i386/syscall_arch.h
index 4c9d874..4dd2a31 100644
--- a/arch/i386/syscall_arch.h
+++ b/arch/i386/syscall_arch.h
@@ -52,8 +52,4 @@ static inline long __syscall6(long n, long a1, long a2, long a3, long a4, long a
 	return __ret;
 }
 
-#define VDSO_USEFUL
-#define VDSO_CGT_SYM "__vdso_clock_gettime"
-#define VDSO_CGT_VER "LINUX_2.6"
-
 #define SYSCALL_USE_SOCKETCALL
diff --git a/arch/mips/syscall_arch.h b/arch/mips/syscall_arch.h
index 666f413..ae9ffe7 100644
--- a/arch/mips/syscall_arch.h
+++ b/arch/mips/syscall_arch.h
@@ -120,7 +120,3 @@ static inline long __syscall6(long n, long a, long b, long c, long d, long e, lo
 	if (n == SYS_fstatat64) __stat_fix(c);
 	return r2;
 }
-
-#define VDSO_USEFUL
-#define VDSO_CGT_SYM "__vdso_clock_gettime"
-#define VDSO_CGT_VER "LINUX_2.6"
diff --git a/arch/mips64/syscall_arch.h b/arch/mips64/syscall_arch.h
index 5eabdf4..4be9a37 100644
--- a/arch/mips64/syscall_arch.h
+++ b/arch/mips64/syscall_arch.h
@@ -219,7 +219,3 @@ static inline long __syscall6(long n, long a, long b, long c, long d, long e, lo
 
 	return r2;
 }
-
-#define VDSO_USEFUL
-#define VDSO_CGT_SYM "__vdso_clock_gettime"
-#define VDSO_CGT_VER "LINUX_2.6"
diff --git a/arch/mipsn32/syscall_arch.h b/arch/mipsn32/syscall_arch.h
index 93a026f..0d0f632 100644
--- a/arch/mipsn32/syscall_arch.h
+++ b/arch/mipsn32/syscall_arch.h
@@ -118,7 +118,3 @@ static inline long __syscall6(long n, long a, long b, long c, long d, long e, lo
 	if (n == SYS_newfstatat) __stat_fix(c);
 	return r2;
 }
-
-#define VDSO_USEFUL
-#define VDSO_CGT_SYM "__vdso_clock_gettime"
-#define VDSO_CGT_VER "LINUX_2.6"
diff --git a/arch/x86_64/syscall_arch.h b/arch/x86_64/syscall_arch.h
index 54e05ff..a85c440 100644
--- a/arch/x86_64/syscall_arch.h
+++ b/arch/x86_64/syscall_arch.h
@@ -60,9 +60,3 @@ static __inline long __syscall6(long n, long a1, long a2, long a3, long a4, long
 						  "d"(a3), "r"(r10), "r"(r8), "r"(r9) : "rcx", "r11", "memory");
 	return ret;
 }
-
-#define VDSO_USEFUL
-#define VDSO_CGT_SYM "__vdso_clock_gettime"
-#define VDSO_CGT_VER "LINUX_2.6"
-#define VDSO_GETCPU_SYM "__vdso_getcpu"
-#define VDSO_GETCPU_VER "LINUX_2.6"
diff --git a/src/internal/vdso.c b/src/internal/vdso.c
deleted file mode 100644
index d46d322..0000000
--- a/src/internal/vdso.c
+++ /dev/null
@@ -1,93 +0,0 @@
-#include <elf.h>
-#include <link.h>
-#include <limits.h>
-#include <stdint.h>
-#include <string.h>
-#include "libc.h"
-#include "syscall.h"
-
-#ifdef VDSO_USEFUL
-
-#if ULONG_MAX == 0xffffffff
-typedef Elf32_Ehdr Ehdr;
-typedef Elf32_Phdr Phdr;
-typedef Elf32_Sym Sym;
-typedef Elf32_Verdef Verdef;
-typedef Elf32_Verdaux Verdaux;
-#else
-typedef Elf64_Ehdr Ehdr;
-typedef Elf64_Phdr Phdr;
-typedef Elf64_Sym Sym;
-typedef Elf64_Verdef Verdef;
-typedef Elf64_Verdaux Verdaux;
-#endif
-
-static int checkver(Verdef *def, int vsym, const char *vername, char *strings)
-{
-	vsym &= 0x7fff;
-	for (;;) {
-		if (!(def->vd_flags & VER_FLG_BASE)
-		  && (def->vd_ndx & 0x7fff) == vsym)
-			break;
-		if (def->vd_next == 0)
-			return 0;
-		def = (Verdef *)((char *)def + def->vd_next);
-	}
-	Verdaux *aux = (Verdaux *)((char *)def + def->vd_aux);
-	return !strcmp(vername, strings + aux->vda_name);
-}
-
-#define OK_TYPES (1<<STT_NOTYPE | 1<<STT_OBJECT | 1<<STT_FUNC | 1<<STT_COMMON)
-#define OK_BINDS (1<<STB_GLOBAL | 1<<STB_WEAK | 1<<STB_GNU_UNIQUE)
-
-void *__vdsosym(const char *vername, const char *name)
-{
-	size_t i;
-	for (i=0; libc.auxv[i] != AT_SYSINFO_EHDR; i+=2)
-		if (!libc.auxv[i]) return 0;
-	if (!libc.auxv[i+1]) return 0;
-	Ehdr *eh = (void *)libc.auxv[i+1];
-	Phdr *ph = (void *)((char *)eh + eh->e_phoff);
-	size_t *dynv=0, base=-1;
-	for (i=0; i<eh->e_phnum; i++, ph=(void *)((char *)ph+eh->e_phentsize)) {
-		if (ph->p_type == PT_LOAD)
-			base = (size_t)eh + ph->p_offset - ph->p_vaddr;
-		else if (ph->p_type == PT_DYNAMIC)
-			dynv = (void *)((char *)eh + ph->p_offset);
-	}
-	if (!dynv || base==(size_t)-1) return 0;
-
-	char *strings = 0;
-	Sym *syms = 0;
-	Elf_Symndx *hashtab = 0;
-	uint16_t *versym = 0;
-	Verdef *verdef = 0;
-	
-	for (i=0; dynv[i]; i+=2) {
-		void *p = (void *)(base + dynv[i+1]);
-		switch(dynv[i]) {
-		case DT_STRTAB: strings = p; break;
-		case DT_SYMTAB: syms = p; break;
-		case DT_HASH: hashtab = p; break;
-		case DT_VERSYM: versym = p; break;
-		case DT_VERDEF: verdef = p; break;
-		}
-	}	
-
-	if (!strings || !syms || !hashtab) return 0;
-	if (!verdef) versym = 0;
-
-	for (i=0; i<hashtab[1]; i++) {
-		if (!(1<<(syms[i].st_info&0xf) & OK_TYPES)) continue;
-		if (!(1<<(syms[i].st_info>>4) & OK_BINDS)) continue;
-		if (!syms[i].st_shndx) continue;
-		if (strcmp(name, strings+syms[i].st_name)) continue;
-		if (versym && !checkver(verdef, versym[i], vername, strings))
-			continue;
-		return (void *)(base + syms[i].st_value);
-	}
-
-	return 0;
-}
-
-#endif
diff --git a/src/sched/sched_getcpu.c b/src/sched/sched_getcpu.c
index e08cfdf..b9cd0b6 100644
--- a/src/sched/sched_getcpu.c
+++ b/src/sched/sched_getcpu.c
@@ -4,40 +4,11 @@
 #include "syscall.h"
 #include "atomic.h"
 
-#ifdef VDSO_GETCPU_SYM
-
-void *__vdsosym(const char *, const char *);
-
-static void *volatile vdso_func;
-
-typedef long (*getcpu_f)(unsigned *, unsigned *, void *);
-
-static long getcpu_init(unsigned *cpu, unsigned *node, void *unused)
-{
-	void *p = __vdsosym(VDSO_GETCPU_VER, VDSO_GETCPU_SYM);
-	getcpu_f f = (getcpu_f)p;
-	a_cas_p(&vdso_func, (void *)getcpu_init, p);
-	return f ? f(cpu, node, unused) : -ENOSYS;
-}
-
-static void *volatile vdso_func = (void *)getcpu_init;
-
-#endif
-
 int sched_getcpu(void)
 {
 	int r;
 	unsigned cpu;
 
-#ifdef VDSO_GETCPU_SYM
-	getcpu_f f = (getcpu_f)vdso_func;
-	if (f) {
-		r = f(&cpu, 0, 0);
-		if (!r) return cpu;
-		if (r != -ENOSYS) return __syscall_ret(r);
-	}
-#endif
-
 	r = __syscall(SYS_getcpu, &cpu, 0, 0);
 	if (!r) return cpu;
 	return __syscall_ret(r);
diff --git a/src/time/clock_gettime.c b/src/time/clock_gettime.c
index 2412880..a823a71 100644
--- a/src/time/clock_gettime.c
+++ b/src/time/clock_gettime.c
@@ -5,44 +5,10 @@
 #include "libc.h"
 #include "atomic.h"
 
-#ifdef VDSO_CGT_SYM
-
-void *__vdsosym(const char *, const char *);
-
-static void *volatile vdso_func;
-
-static int cgt_init(clockid_t clk, struct timespec *ts)
-{
-	void *p = __vdsosym(VDSO_CGT_VER, VDSO_CGT_SYM);
-	int (*f)(clockid_t, struct timespec *) =
-		(int (*)(clockid_t, struct timespec *))p;
-	a_cas_p(&vdso_func, (void *)cgt_init, p);
-	return f ? f(clk, ts) : -ENOSYS;
-}
-
-static void *volatile vdso_func = (void *)cgt_init;
-
-#endif
-
 int __clock_gettime(clockid_t clk, struct timespec *ts)
 {
 	int r;
 
-#ifdef VDSO_CGT_SYM
-	int (*f)(clockid_t, struct timespec *) =
-		(int (*)(clockid_t, struct timespec *))vdso_func;
-	if (f) {
-		r = f(clk, ts);
-		if (!r) return r;
-		if (r == -EINVAL) return __syscall_ret(r);
-		/* Fall through on errors other than EINVAL. Some buggy
-		 * vdso implementations return ENOSYS for clocks they
-		 * can't handle, rather than making the syscall. This
-		 * also handles the case where cgt_init fails to find
-		 * a vdso function to use. */
-	}
-#endif
-
 	r = __syscall(SYS_clock_gettime, clk, ts);
 	if (r == -ENOSYS) {
 		if (clk == CLOCK_REALTIME) {
-- 
2.25.1

